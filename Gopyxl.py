from collections import OrderedDict
import pdb
import os
import pickle
import re
import datetime

# v2 Major changes
# Goma arguments for BoundaryCondition are a single string from a single cell in the spreadsheet.  This was done
# to accomodate other boundary conditions such as custom Dirichlet conditions which have more input arguments
# than simply int and float datum.

class Gopyxl(object):
    def __init__(self, xslx_file_info, FEM_file_dict, General_dict, Time_integration_dict, \
        Solver_dict, MatField_list, Boundaries_dict, BC_dict, pp_dict):
        self.FEM_file_dict = FEM_file_dict
        self.General_dict = General_dict
        self.Time_integration_dict = Time_integration_dict
        self.Solver_dict = Solver_dict
        self.MatField_list = MatField_list
        self.Boundaries_dict = Boundaries_dict
        self.BC_dict = BC_dict
        self.pp_dict=pp_dict
        self.xlsx_file_info = xslx_file_info
        self.gopyxl_filepath = os.path.join(os.getcwd(), 'flow.gopyxl')

    def print_goma_input(self):
        for s in self.goma_input_strs:
            print (s)

    def write_goma_input(self,filepath='input.inp'):
        with open(filepath, 'w+') as f:
            for s in self.goma_input_strs:
                f.write(str(s) + '\n')
    
        print('read the file: \n\t' + os.path.abspath(self.xlsx_file_info['xlsx']))
        print('input file written as: \n\t' + os.path.abspath(filepath))
        # + self.file_info['drive'] + self.file_info['path']

    # Save the gopyxl using pickle.dump
    def save(self, filepath='flow.gopyxl'):
        with open(self.gopyxl_filepath, 'wb') as ff:
            pickle.dump(self, ff)

        print('gopyxl file written as: \n\t' + self.gopyxl_filepath)

    # Add a fancy title in the input file
    def add_title(self, title):
        s = re.sub('[a-zA-Z]', '-', title)
        return s+'\n'+title+'\n'+s

    # Writes a dictionary as "key = value" for input file
    def format_input(self, input_dict):
        output=list()
        for key,value in input_dict.items():
                if type(value) is bool:
                    if value is True:
                        output.append("{0:40}{1} {2}".format(key, "=","on"))
                    else:
                        output.append("{0:40}{1} {2}".format(key, "=","off"))
                else:
                    if value == None:
                        pass
                    else:
                        output.append("{0:40}{1} {2}".format(key, "=",value))

        return output

    # Returns the number of active material fields
    @property
    def num_matfields (self):
        active_matfields = [matfield for matfield in self.MatField_list if matfield.active]
        return len(active_matfields)

    # Compiles the whole damn input file as an array of strings
    @property
    def goma_input_strs (self):
        goma_input = list()
        # goma_input = ['hello']

        # Write preamble
        goma_input.append('# Generated by Gopyxl')
        goma_input.append('# XSLX = ' + os.path.join(self.xlsx_file_info['path'], self.xlsx_file_info['xlsx']))
        goma_input.append('# Gopyxl = ' + self.gopyxl_filepath)
        goma_input.append('# ' + datetime.datetime.today().strftime('%m-%d-%Y') + ' ' + datetime.datetime.today().strftime('%H:%M:%S'))

        # Write Setup
        goma_input.append(self.add_title('FEM File Specifications'))
        goma_input = goma_input + self.format_input(self.FEM_file_dict)
        goma_input.append('')

        # Write General Specifications
        goma_input.append(self.add_title('General Specifications'))
        goma_input = goma_input + self.format_input(self.General_dict)
        goma_input.append('')

        # Write Time Integration Specifications
        # pdb.set_trace()
        goma_input.append(self.add_title('Time Integration Specifications'))
        goma_input = goma_input + self.format_input(self.Time_integration_dict)
        goma_input.append('')

        # Write Solver Specifications
        goma_input.append(self.add_title('Solver Specifications'))
        goma_input = goma_input + self.format_input(self.Solver_dict)
        goma_input.append('')

        # Write Boundary Conditions
        goma_input.append(self.add_title('Boundary Conditions'))
        goma_input.append('Number of BC = -1')

        unq_boundaries = set()
        # Generate a set of unique boundary names
        for i, Boundary in self.Boundaries_dict.items():
            unq_boundaries.add(Boundary.name)

        # Sort the boundary names, and for each boundary, list the relevant conditions
        # pdb.set_trace()
        for i, Bname in enumerate(sorted(unq_boundaries)):
            relevant_BCs = [BC[-1] for BC in self.BC_dict.items() if BC[-1].Boundary.name is Bname]

            # pdb.set_trace()
            if len(relevant_BCs) > 0:
                goma_input.append('### ' + Bname + ' ###')
                for BC in relevant_BCs:
                    if BC.Boundary.name == Bname:
                        goma_input.append(BC.ctrl_line)
            
                goma_input.append('')


        goma_input.append('\nEND OF BC\n')

        # Write Problem Description
        goma_input.append(self.add_title('Problem Description'))
        goma_input.append('Number of Materials = {}'.format(self.num_matfields)+'\n')

        # For each material
        for i, matfield in enumerate(self.MatField_list):
            goma_input.append(matfield.name_line(i+1))
            goma_input.append(matfield.ctrl_line)

            # Then write the field equations and their weights.  DiffEq objects already have
            # a built-in function that outputs 
            for j, DiffEq in enumerate(matfield.DiffEq_list):

                # pdb.set_trace()
                goma_input.append(DiffEq.input_line)

            goma_input.append('')
        goma_input.append('\nEND OF EQ\n')

        

        # Write Time Post Processing Specifications
        goma_input.append(self.add_title('Post Processing Specifications'))
        # goma_input = goma_input + self.format_input(self.pp_dict)
        # goma_input.append('')

        for key, value in self.pp_dict.items():
            if value:
                goma_input.append(key + ' = yes')
        # print goma_input
        return goma_input


    def getParameter(self, Parameter_name, Material_id=-1):

        if Material_id == -1:
            Energy_parameters = ['ThermalPeclet', 'Conductivity', 'Prandtl']
            Flow_parameters= ['Reynolds', 'Stokes', 'Rayleigh', 'Viscosity', 'Density', 'Gravity Angle']
            Mesh_parameters = ['MeshCompress']

            if Parameter_name in Energy_parameters:
                Material_id = self.commands_regions_dict['energy'][0]
            elif Parameter_name in Flow_parameters:
                Material_id = self.commands_regions_dict['flow'][0]
            elif Parameter_name in Mesh_parameters:
                Material_id = self.commands_regions_dict['mesh'][0]

        # print Parameter_name
        # print Material_id
        curr = [material.properties for material in self.Materials_list if material.id == Material_id][0]
        ref = [material.properties for material in self.Materials_list if material.id == 1][0]

        for case in switch(Parameter_name):
            if case('Reynolds'):
                reynolds = curr['Density']*self.Charac['Velocity']*self.Charac['Length']/ref['Viscosity']
                return reynolds
                break
            if case('Stokes'):
                stokes = curr['Density']*self.Charac['GravityConstant']*self.Charac['Length']**2/ref['Viscosity']
                return stokes
                break
            if case('Rayleigh'):
                rayleigh = curr['Density']*self.Charac['GravityConstant']*self.Charac['Length']**2*curr['Thermal expansivity']*\
                self.Charac['Temperature']/curr['Viscosity']/self.Charac['Velocity']
                return rayleigh
                break
            if case('Viscosity'):
                viscosity = curr['Viscosity'] / ref['Viscosity']
                return viscosity
                break
            if case('ThermalPeclet'):
                thermalpeclet = curr['Density']*curr['Specific heat']*self.Charac['Length']*self.Charac['Velocity']/\
                curr['Thermal conductivity']
                return thermalpeclet
                break
            if case('Prandtl'):
                prandtl = curr['Density']*curr['Specific heat']*self.Charac['Diffusivity']/curr['Thermal conductivity']
                return prandtl
                break
            if case('Conductivity'):
                conductivity = curr['Thermal conductivity']/ref['Thermal conductivity']
                return conductivity
                break
            if case('Density'):
                density = curr['Density']/ref['Density']
                return density
                break
            if case('Gravity Angle'):
                gravityangle = self.Charac['Gravity Angle']
                return gravityangle
                break


class BoundaryCondition(object):
    
    def __init__(self, id, active, Boundary, bc_type, arguments, expectations):
        self.id = id
        self.Boundary = Boundary
        self.type = bc_type
        self.arguments = [s for s in re.split('[,; ]', arguments) if s is not '']
        self.expectations = expectations # could use this to check incoming arguments but too lazy to implement now
        
        if active == False:
            self.active = False
        else:
            self.active = True
        
    @property
    def ctrl_line(self):
        
        # num_dict = {True:', ', False:''} 

        line_data1 = ' '.join(['BC = ', self.type, self.Boundary.Btype, str(self.Boundary.id)])
        line_data2 = ' '.join(self.arguments)

        output = ' '.join([line_data1, line_data2])
        
        # output = str("bc(" + str(self.id) + ', ' + self.type + ", (" + \
        #     str(self.Boundary.id) + ", (" + str(len(self.int_data)) + num_dict[len(self.int_data)>0] + \
        #     str(self.int_data).strip("[]") + "), (" + str(len(self.real_data)) + num_dict[len(self.real_data)>0] + str(self.real_data).strip("[]") + ")))")
        
        if self.active:
            return output
        
        else:
            return '#\t' + output
#      
class Boundary(object):
    
    def __init__(self, id, name, Btype):
        self.id = id
        self.name = name
        self.Btype = Btype

class DiffEq(object):

    def __init__(self, name, diffeq_active, variable, Galerkin_wt, Interp_fn, weights):
        self.name = name
        self.active = diffeq_active
        self.variable = variable
        self.Galerkin_wt = Galerkin_wt
        self.Interp_fn = Interp_fn
        weight_names = ['div', 'ms', 'adv', 'bnd', 'dif', 'src', 'por']
        self.weights = OrderedDict(zip(weight_names, [float(s) if s is not None else None for s in weights]))

    @property
    def input_line(self):
        weight_line = ['' if s[1] is None else str(s[1]) for s in self.weights.items()]
        output = '\tEQ = ' + self.name + '\t' + self.Galerkin_wt + '\t' + self.variable + '\t' + \
            self.Interp_fn + '\t'+ '\t'.join([s for s in weight_line])

        if self.active:
            return output
        else:
            return '#' + output


class MaterialField(object):
    def __init__(self, material_name, opts_dict, matfield_active, DiffEq_list):


        for key in opts_dict:
            setattr(self, key, opts_dict[key])          

        self.active = matfield_active
        self.DiffEq_list = DiffEq_list
        self.name = material_name
        self.coordinate_sys = opts_dict['Coordinate System']
        self.elem_mapping = opts_dict['Element Mapping']
        self.mesh_motion = opts_dict['Mesh Motion']
        self.num_species = opts_dict['# of bulk species']


    @property
    def num_DEs(self):
        active_DEs = [DE for DE in self.DiffEq_list if DE.active]
        return len(active_DEs)

    def name_line(self, id):
        if self.active:
            return 'MAT = ' + self.name + '\t' + str(id)
        else:
            return '#MAT = ' + self.name + '\t' + str(id)

    @property
    def ctrl_line(self):
        line1 = '\tCoordinate System = ' + self.coordinate_sys.upper()
        line2 = '\tElement Mapping = ' + self.elem_mapping.lower()
        line3 = '\tMesh Motion = ' + self.mesh_motion.upper()
        line4 = '\tNumber of bulk species = ' + str(self.num_species)+'\n'
        line5 = '\tNumber of EQ = ' + str(self.num_DEs)
        if self.active:

            return '\n'.join([line1, line2, line3, line4, line5])
        else:
            return '\n'.join(['#'+line1, '#'+line2, '#'+line3, '#'+line4, '#'+line5])


class switch(object):
    def __init__(self, value):
        self.value = value
        self.fall = False

    def __iter__(self):
        """Return the match method once, then stop"""
        yield self.match
        raise StopIteration
    
    def match(self, *args):
        """Indicate whether or not to enter a case suite"""
        if self.fall or not args:
            return True
        elif self.value in args: # changed for v1.5, see below
            self.fall = True
            return True
        else:
            return False